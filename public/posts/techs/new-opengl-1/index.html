<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>OpenGL 学习笔记 1 | Ca2D Pages</title><meta name=keywords content="OpenGL"><meta name=description content="三角形的初体验"><meta name=author content="Ca2didi"><link rel=canonical href=https://ca2didi.xyz/posts/techs/new-opengl-1/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ca2didi.xyz/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://ca2didi.xyz/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://ca2didi.xyz/favicon-32x32.png><link rel=apple-touch-icon href=https://ca2didi.xyz/apple-touch-icon.png><link rel=mask-icon href=https://ca2didi.xyz/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="OpenGL 学习笔记 1"><meta property="og:description" content="三角形的初体验"><meta property="og:type" content="article"><meta property="og:url" content="https://ca2didi.xyz/posts/techs/new-opengl-1/"><meta property="og:image" content="https://ca2didi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-10-27T11:30:03+00:00"><meta property="article:modified_time" content="2021-10-27T11:30:03+00:00"><meta property="og:site_name" content="Ca2D Pages"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ca2didi.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="OpenGL 学习笔记 1"><meta name=twitter:description content="三角形的初体验"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ca2didi.xyz/posts/"},{"@type":"ListItem","position":2,"name":"OpenGL 学习笔记 1","item":"https://ca2didi.xyz/posts/techs/new-opengl-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"OpenGL 学习笔记 1","name":"OpenGL 学习笔记 1","description":"三角形的初体验","keywords":["OpenGL"],"articleBody":"我志向学习游戏客户端开发，在此之前已经有了2年左右的业余Unity开发经验。现在升上大学，我想我也应该有时间去学习更为进阶的内容了。因此我准备通过自学OpenGL来写一个小的游戏引擎，来学习Shader与游戏引擎构架。\n由于学习笔记对于我来说是对我不容易记住的东西进行补充说明与个人理解，因此不会说的非常详细，仅仅是对参考资料的一个补充。\n话不多说，下面就是我的笔记正文。\n参考资料 目前参考资料是：\n LearnOpenGL CN 一个非常好用的OpenGL入门教程网站，必看。 OpenGL Wiki OpenGL的官方文档，够正的。  OpenGL是什么 OpenGL是一个图形库（而且也仅仅是一个图形库，没有输入、声音和窗口管理的库函数），其本质是通过一套开源标准，让硬件与软件得以连接的API。现代显卡都支持OpenGL API。\nOpenGL API本质上是一个状态机，因此我们需要在OpenGL每一次绘图之前对OpenGL的参数进行配置，才能让图形如我们所愿。（因此OpenGL也提供了一种参数的简记手段）\n由于OpenGL本质上是一套开源标准，因此显卡真正的运行时API与OpenGL API必定不同，OpenGL需要在运行时对实际调用显卡的API进行重定向。这就导致了OpenGL的运行效率会有损失。\nGLFW与GLAD 之前提到过OpenGL是没有Input和Audio之类的功能，甚至连在操作系统下创建窗口的功能都没有，因此我们需要额外的库来做支持。GLFW就是做这些事情的一个库了。GLFW实现了系统环境支持，为应用提供了一套很好用的库，关键是它也是跨平台的。\n那么GLAD是干什么的呢？GLAD的功能在于为OpenGL提供了重定向功能，使之可以调用到显卡中具体的操作函数（上面提到过了！）\n开发环境配置 我之前没有学过C++，因此我这次尝试使用C++来学习OpenGL。学习OpenGL的同时也学会了C++，岂不美哉。\n我具体的开发环境是macOS Big Sur(arm64) + Clang + Clion。我尝试使用教程中的做法来自己编译运行库，但是最后终归失败。\n最后我使用了homebrew来导入运行库：\nbrew install glfw 安装完成后，我们可以在 /opt/homebrew/Cellar/ 下找到我们的glfw。\n接下来按照LearnOpenGL的说法，去 https://glad.dav1d.de 下载glad后，构建项目目录结构如下所示：\nProjectRoot |- CMakeLists.txt |- src // 放置本项目源代码 |- includes // 放置头文件 |- libs // 放置引用库 将glad解压缩后，分别把内容中的include和lib放在我们项目中的对应目录。接下来，我们编写CMakeList如下所示：\ncmake_minimum_required(VERSION 3.20)project(LearnOpenGL)set(CMAKE_CXX_STANDARD 11)# 设置变量 set(GLFW_HOME \"/opt/homebrew/Cellar/glfw/3.3.4\")# 设置头文件目录 include_directories(\"${GLFW_HOME}/include\")include_directories(/include)# 添加 GLFW3 预编译库 add_library(glfw SHARED IMPORTED)SET_TARGET_PROPERTIES(glfw PROPERTIES IMPORTED_LOCATION \"${GLFW_HOME}/lib/libglfw.3.3.dylib\")add_executable(LearnOpenGL src/main.cpp \"libs/glad.c\")target_link_libraries(LearnOpenGL glfw \"-framework OpenGL\")在Clion中更新CMakeLists文件之后，没有报错就没有问题了。接下来我们可以开始编写三角形的代码了。\n（其实我觉得，glad也可以放在系统里面，作为系统的库来引用会更加方便一些）\n制作三角形的的一些备注 下面就是一些我容易搞错的部分了，也是我学习的时候半天反应不过来的东西。\n函数怎么区分 在使用OpenGL的过程中，我们会用到三种前缀的函数：\nglXXX(); // 真正的OpenGL函数 glfwXXX(); // 这个是glfw的函数 gladXXX(); // 这个是glad的函数 要记忆这三种函数前缀和其对应功能我觉得还是蛮简单的：gl只管绘图工作、其他的什么窗口创建和管理和输入处理之类的都是glfw的工作、而glad是管理OpenGL重定向工作，因此只会使用到一次 gladLoadGLLoader() 。\nglGenXXX 到底生成了个啥东西 在文档里面，glGenXXX()是用来创建OpenGL对象的一个通用方法，比如使用glGenBuffers()来创建缓冲对象，glGenVertexArrays()来创建顶点数组对象。但问题是，这俩东西生成在哪儿？\n这个时候不得不提到CPU和GPU的数据传输问题了。这个是个老生常谈的问题，其基本描述是：如果图形数据一直都要保持在CPU的内存中，那么每次GPU绘制图形的时候，都要先让CPU来发送数据到GPU，GPU才能得到数据，这导致了GPU读取数据的最快速度取决于CPU发送数据能有多快，因此产生了瓶颈。\n为了解决这个瓶颈，我们提出了缓冲区。通过将需要绘制的顶点数据（大量的）提前提交到GPU的内存中，使得GPU得以减少与CPU通讯量，从而提高计算速度。\n这个问题清楚了，glGenBuffers()是什么就很好解释了。glGenBuffers()实质上就是在显存里面开辟一块内存空间后，将这个空间的地址（可能也不是地址）交给CPU，让CPU知道缓冲区的位置在哪里，方便CPU写数据。\n换言之，这个调用类似于在GPU的内存上申请了一块空间，并且给GPU返回了这块内存的地址（类似于返回一个显存上的指针）。\nglGenVertexArrays()理论上应该会和glGenBuffers()一致，只是它的类型不是Buffer而已。我总感觉有没有可能会有不一样的地方，但是我还没查到（大概率没有吧）。\nVertex Array Object、Buffer Object 与 Attribute Pointer 的关系 Vertex Array Object是一种用来记录Buffer和Attribute Pointer的数据体。有点听不懂，我也有点迷，所以要仔细补充一下我的理解，这个是重点。\nBuffer是缓冲区，Attribute Pointer是用来解释缓冲区数据是怎么放的说明（也就是属性）。我们的GPU和CPU一样是傻瓜，必须得有人给他细说一下我们给了它什么东西，它才知道怎样才能正确的读取我们给他的数据。我们在给GPU喂Buffer的时候，就必须要给他喂“食用指南”Attribute Pointer。\n这里先要提一嘴：Buffer实际上还可以存储颜色数据和贴图数据等东西，为了方便GPU取数据，我们可以让顶点数据后面紧贴颜色和贴图的数据。因此我们必须告知GPU什么地方是顶点数据，什么地方是颜色数据等等。\n我们知道像顶点、颜色和贴图之类的数据，都要通过渲染管线才能变成我们显示器上的像素颜色值。渲染管线里面的Vertex Shader是渲染的开始，因此我们可以知道一件事情，Buffer里面的数据先要走过Vertex Shader才能继续被处理。我们可以猜测到Vertex Shader不仅仅要处理顶点数据，它可能还要给其他的数据进行处理。因此，我们需要找到一个办法把两边的数据连接起来。\n这个时候我们就要祭出Layout了。\nLayout出现在了Vertex Shader和定义Attribute Pointer（也就是函数glVertexAttribPointer）两个地方。在Vertex Shader中，Layout指的是这个数据是从哪里输入的；在Attribute Pointer里面，Layout指的是数据要输给谁。一个头一个尾，拼在一起刚刚好。\n因此总结，我们给Buffer定义Attribute Pointer来告知OpenGL如何读取和解释Buffer里面的数据给Shader。\n这个时候我们回到Vertex Array Object，这玩意就是用来存放我们这一对Buffer和Attribute Pointer的地方。因为VAO名字里面有Array，可推断VAO可以存储很多对Buffer和Attribute Pointer。\n这个时候配上LearnOpenGL的图，感觉突然好懂了一些：\nVAO的结构示意图 等下，还有一个问题：再上图中，为什么VAO只保存了Attribute Pointer指针和EBO，没有保存Buffer的指针？因为Buffer的指针被放在了Attribute Pointer里面，我用C来描述一下就是\nstruct VAO {  struct AP[16] attributePointers;  struct EBO* elementBufferObject; }  struct AP {  struct Buffer* buffer;  // and code to guide OpenGL read buffer data  // ... } 不吓人的 glBindXXX 之前我们讨论过OpenGL本质上是一个状态机，因此我们需要在每一次绘图之前配置好我们“画笔”的参数，让它画出我们希望的图形。但是每一次画同样的东西都要让我重新配置OpenGL的话，是不是性能损耗太大了？\n上面提到的Vertex Array Object就是用来解决这个问题的。我们预先定义好的“画笔”参数，到时候要用什么画笔直接拿来就能画，岂不美哉？\n我们在绘制前，都需要调用glBindVertexArray()来绑定VAO与OpenGL，然后我们的OpenGL就会按VAO的信息来绘制图形。但其实我觉得一个比较讨厌的点在于，glBindXXX()调用的很频繁，有时候可能会弄不清楚我这个glBindXXX()是在干什么。所以我在这里简单补充一下LearnOpenGL的内容：\n// 首先，我们要先绑定VAO，才能保证后续的操作是在给我们预期的VAO操作 glBindVertexArray(VAO);  // 然后，我们绑定我们要操作的Buffer // 需要注意的是，我们可以同时绑定Element Buffer和Array Buffer。 // 我们后续的操作对操作目标是很明确的，不用担心数据错位 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBindBuffer(GL_ELEMENT_BUFFER, EBO);  // 接下来，给Buffer塞数据 glBufferData(GL_ARRAY_BUFFER, ...); glBufferData(GL_ELEMENT_BUFFER, ...);  // 数据塞好了，给Vertex Array Buffer定义Attribute Pointer // 我曾疑惑为什么不在这里设定Buffer类型，但实际上这个函数只会使用到当前绑定的VAO，而不会使用到EBO glVertexAttribPointer(...);  // 启用刚刚做好的Attribute Pointer glEnableVertexAttribArray(0);  // 解除当前的所有绑定，方便进行下一步操作 glBindVertexArray(0); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindBuffer(GL_ELEMENT_BUFFER, 0); 总结 实际上，在怎样使用OpenGL上的难点主要是搞清楚VAO、VBO和EBO三者的关系。这三者搞清楚了，OpenGL API剩下的内容都不会太难（但我没说图形学简单啊），只是说会很多很杂了。\n","wordCount":"219","inLanguage":"zh","datePublished":"2021-10-27T11:30:03Z","dateModified":"2021-10-27T11:30:03Z","author":{"@type":"Person","name":"Ca2didi"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ca2didi.xyz/posts/techs/new-opengl-1/"},"publisher":{"@type":"Organization","name":"Ca2D Pages","logo":{"@type":"ImageObject","url":"https://ca2didi.xyz/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ca2didi.xyz/ accesskey=h title="Ca2D Pages (Alt + H)">Ca2D Pages</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ca2didi.xyz/categories/ title=分类><span>分类</span></a></li><li><a href=https://ca2didi.xyz/tags/ title=标签><span>标签</span></a></li><li><a href=https://comet.studio title=彗星工作室><span>彗星工作室</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>OpenGL 学习笔记 1</h1><div class=post-description>三角形的初体验</div><div class=post-meta><span title="2021-10-27 11:30:03 +0000 +0000">2021/10/27</span>&nbsp;·&nbsp;Ca2didi&nbsp;|&nbsp;<a href=https://github.com/Cardidi/my-page/content/posts/techs/new-opengl-1.md rel="noopener noreferrer" target=_blank>在 Github 上查看原Markdown</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99 aria-label=参考资料>参考资料</a></li><li><a href=#opengl%e6%98%af%e4%bb%80%e4%b9%88 aria-label=OpenGL是什么>OpenGL是什么</a></li><li><a href=#glfw%e4%b8%8eglad aria-label=GLFW与GLAD>GLFW与GLAD</a></li><li><a href=#%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae aria-label=开发环境配置>开发环境配置</a></li><li><a href=#%e5%88%b6%e4%bd%9c%e4%b8%89%e8%a7%92%e5%bd%a2%e7%9a%84%e7%9a%84%e4%b8%80%e4%ba%9b%e5%a4%87%e6%b3%a8 aria-label=制作三角形的的一些备注>制作三角形的的一些备注</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e6%80%8e%e4%b9%88%e5%8c%ba%e5%88%86 aria-label=函数怎么区分>函数怎么区分</a></li><li><a href=#glgenxxx-%e5%88%b0%e5%ba%95%e7%94%9f%e6%88%90%e4%ba%86%e4%b8%aa%e5%95%a5%e4%b8%9c%e8%a5%bf aria-label="glGenXXX 到底生成了个啥东西">glGenXXX 到底生成了个啥东西</a></li><li><a href=#vertex-array-objectbuffer-object-%e4%b8%8e-attribute-pointer-%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="Vertex Array Object、Buffer Object 与 Attribute Pointer 的关系">Vertex Array Object、Buffer Object 与 Attribute Pointer 的关系</a></li><li><a href=#vao%e7%9a%84%e7%bb%93%e6%9e%84%e7%a4%ba%e6%84%8f%e5%9b%be aria-label=VAO的结构示意图>VAO的结构示意图</a></li><li><a href=#%e4%b8%8d%e5%90%93%e4%ba%ba%e7%9a%84-glbindxxx aria-label="不吓人的 glBindXXX">不吓人的 glBindXXX</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><p>我志向学习游戏客户端开发，在此之前已经有了2年左右的业余Unity开发经验。现在升上大学，我想我也应该有时间去学习更为进阶的内容了。因此我准备通过自学OpenGL来写一个小的游戏引擎，来学习Shader与游戏引擎构架。</p><p>由于学习笔记对于我来说是对我不容易记住的东西进行补充说明与个人理解，因此不会说的非常详细，仅仅是对参考资料的一个补充。</p><p>话不多说，下面就是我的笔记正文。</p><h1 id=参考资料>参考资料<a hidden class=anchor aria-hidden=true href=#参考资料>#</a></h1><p>目前参考资料是：</p><ul><li>LearnOpenGL CN 一个非常好用的OpenGL入门教程网站，必看。</li><li>OpenGL Wiki OpenGL的官方文档，够正的。</li></ul><h1 id=opengl是什么>OpenGL是什么<a hidden class=anchor aria-hidden=true href=#opengl是什么>#</a></h1><p>OpenGL是一个图形库（而且也仅仅是一个图形库，没有输入、声音和窗口管理的库函数），其本质是通过一套开源标准，让硬件与软件得以连接的API。现代显卡都支持OpenGL API。</p><p>OpenGL API本质上是一个状态机，因此我们需要在OpenGL每一次绘图之前对OpenGL的参数进行配置，才能让图形如我们所愿。（因此OpenGL也提供了一种参数的简记手段）</p><p>由于OpenGL本质上是一套开源标准，因此显卡真正的运行时API与OpenGL API必定不同，OpenGL需要在运行时对实际调用显卡的API进行重定向。这就导致了OpenGL的运行效率会有损失。</p><h1 id=glfw与glad>GLFW与GLAD<a hidden class=anchor aria-hidden=true href=#glfw与glad>#</a></h1><p>之前提到过OpenGL是没有Input和Audio之类的功能，甚至连在操作系统下创建窗口的功能都没有，因此我们需要额外的库来做支持。GLFW就是做这些事情的一个库了。GLFW实现了系统环境支持，为应用提供了一套很好用的库，关键是它也是跨平台的。</p><p>那么GLAD是干什么的呢？GLAD的功能在于为OpenGL提供了重定向功能，使之可以调用到显卡中具体的操作函数（上面提到过了！）</p><h1 id=开发环境配置>开发环境配置<a hidden class=anchor aria-hidden=true href=#开发环境配置>#</a></h1><p>我之前没有学过C++，因此我这次尝试使用C++来学习OpenGL。学习OpenGL的同时也学会了C++，岂不美哉。</p><p>我具体的开发环境是macOS Big Sur(arm64) + Clang + Clion。我尝试使用教程中的做法来自己编译运行库，但是最后终归失败。</p><p>最后我使用了homebrew来导入运行库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install glfw
</span></span></code></pre></div><p>安装完成后，我们可以在 /opt/homebrew/Cellar/ 下找到我们的glfw。</p><p>接下来按照LearnOpenGL的说法，去 <a href=https://glad.dav1d.de>https://glad.dav1d.de</a> 下载glad后，构建项目目录结构如下所示：</p><pre tabindex=0><code>ProjectRoot
 |- CMakeLists.txt
 |- src // 放置本项目源代码
 |- includes // 放置头文件
 |- libs // 放置引用库
</code></pre><p>将glad解压缩后，分别把内容中的include和lib放在我们项目中的对应目录。接下来，我们编写CMakeList如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmake data-lang=cmake><span style=display:flex><span>cmake_minimum_required(<span style=color:#e6db74>VERSION</span> <span style=color:#e6db74>3.20</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>project(<span style=color:#e6db74>LearnOpenGL</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>set(<span style=color:#e6db74>CMAKE_CXX_STANDARD</span> <span style=color:#e6db74>11</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 设置变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>set(<span style=color:#e6db74>GLFW_HOME</span> <span style=color:#e6db74>&#34;/opt/homebrew/Cellar/glfw/3.3.4&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 设置头文件目录
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>include_directories(<span style=color:#e6db74>&#34;${GLFW_HOME}/include&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>include_directories(<span style=color:#e6db74>/include</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e># 添加 GLFW3 预编译库
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>add_library(<span style=color:#e6db74>glfw</span> <span style=color:#e6db74>SHARED</span> <span style=color:#e6db74>IMPORTED</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>SET_TARGET_PROPERTIES(<span style=color:#e6db74>glfw</span> <span style=color:#e6db74>PROPERTIES</span> <span style=color:#e6db74>IMPORTED_LOCATION</span> <span style=color:#e6db74>&#34;${GLFW_HOME}/lib/libglfw.3.3.dylib&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>add_executable(<span style=color:#e6db74>LearnOpenGL</span> <span style=color:#e6db74>src/main.cpp</span> <span style=color:#e6db74>&#34;libs/glad.c&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>target_link_libraries(<span style=color:#e6db74>LearnOpenGL</span> <span style=color:#e6db74>glfw</span> <span style=color:#e6db74>&#34;-framework OpenGL&#34;</span>)<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>在Clion中更新CMakeLists文件之后，没有报错就没有问题了。接下来我们可以开始编写三角形的代码了。</p><p>（其实我觉得，glad也可以放在系统里面，作为系统的库来引用会更加方便一些）</p><h1 id=制作三角形的的一些备注>制作三角形的的一些备注<a hidden class=anchor aria-hidden=true href=#制作三角形的的一些备注>#</a></h1><p>下面就是一些我容易搞错的部分了，也是我学习的时候半天反应不过来的东西。</p><h2 id=函数怎么区分>函数怎么区分<a hidden class=anchor aria-hidden=true href=#函数怎么区分>#</a></h2><p>在使用OpenGL的过程中，我们会用到三种前缀的函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>glXXX();     <span style=color:#75715e>// 真正的OpenGL函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glfwXXX();   <span style=color:#75715e>// 这个是glfw的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>gladXXX();   <span style=color:#75715e>// 这个是glad的函数
</span></span></span></code></pre></div><p>要记忆这三种函数前缀和其对应功能我觉得还是蛮简单的：gl只管绘图工作、其他的什么窗口创建和管理和输入处理之类的都是glfw的工作、而glad是管理OpenGL重定向工作，因此只会使用到一次 <code>gladLoadGLLoader()</code> 。</p><h2 id=glgenxxx-到底生成了个啥东西>glGenXXX 到底生成了个啥东西<a hidden class=anchor aria-hidden=true href=#glgenxxx-到底生成了个啥东西>#</a></h2><p>在文档里面，<code>glGenXXX()</code>是用来创建OpenGL对象的一个通用方法，比如使用<code>glGenBuffers()</code>来创建缓冲对象，<code>glGenVertexArrays()</code>来创建顶点数组对象。但问题是，这俩东西生成在哪儿？</p><p>这个时候不得不提到CPU和GPU的数据传输问题了。这个是个老生常谈的问题，其基本描述是：如果图形数据一直都要保持在CPU的内存中，那么每次GPU绘制图形的时候，都要先让CPU来发送数据到GPU，GPU才能得到数据，这导致了GPU读取数据的最快速度取决于CPU发送数据能有多快，因此产生了瓶颈。</p><p>为了解决这个瓶颈，我们提出了缓冲区。通过将需要绘制的顶点数据（大量的）提前提交到GPU的内存中，使得GPU得以减少与CPU通讯量，从而提高计算速度。</p><p>这个问题清楚了，<code>glGenBuffers()</code>是什么就很好解释了。<code>glGenBuffers()</code>实质上就是在显存里面开辟一块内存空间后，将这个空间的地址（可能也不是地址）交给CPU，让CPU知道缓冲区的位置在哪里，方便CPU写数据。</p><p>换言之，这个调用类似于在GPU的内存上申请了一块空间，并且给GPU返回了这块内存的地址（类似于返回一个显存上的指针）。</p><p><code>glGenVertexArrays()</code>理论上应该会和<code>glGenBuffers()</code>一致，只是它的类型不是Buffer而已。我总感觉有没有可能会有不一样的地方，但是我还没查到（大概率没有吧）。</p><h2 id=vertex-array-objectbuffer-object-与-attribute-pointer-的关系>Vertex Array Object、Buffer Object 与 Attribute Pointer 的关系<a hidden class=anchor aria-hidden=true href=#vertex-array-objectbuffer-object-与-attribute-pointer-的关系>#</a></h2><p>Vertex Array Object是一种用来记录Buffer和Attribute Pointer的数据体。有点听不懂，我也有点迷，所以要仔细补充一下我的理解，这个是重点。</p><p>Buffer是缓冲区，Attribute Pointer是用来解释缓冲区数据是怎么放的说明（也就是属性）。我们的GPU和CPU一样是傻瓜，必须得有人给他细说一下我们给了它什么东西，它才知道怎样才能正确的读取我们给他的数据。我们在给GPU喂Buffer的时候，就必须要给他喂“食用指南”Attribute Pointer。</p><p>这里先要提一嘴：Buffer实际上还可以存储颜色数据和贴图数据等东西，为了方便GPU取数据，我们可以让顶点数据后面紧贴颜色和贴图的数据。因此我们必须告知GPU什么地方是顶点数据，什么地方是颜色数据等等。</p><p>我们知道像顶点、颜色和贴图之类的数据，都要通过渲染管线才能变成我们显示器上的像素颜色值。渲染管线里面的Vertex Shader是渲染的开始，因此我们可以知道一件事情，Buffer里面的数据先要走过Vertex Shader才能继续被处理。我们可以猜测到Vertex Shader不仅仅要处理顶点数据，它可能还要给其他的数据进行处理。因此，我们需要找到一个办法把两边的数据连接起来。</p><p>这个时候我们就要祭出Layout了。</p><p>Layout出现在了Vertex Shader和定义Attribute Pointer（也就是函数glVertexAttribPointer）两个地方。在Vertex Shader中，Layout指的是这个数据是从哪里输入的；在Attribute Pointer里面，Layout指的是数据要输给谁。一个头一个尾，拼在一起刚刚好。</p><p>因此总结，我们给Buffer定义Attribute Pointer来告知OpenGL如何读取和解释Buffer里面的数据给Shader。</p><p>这个时候我们回到Vertex Array Object，这玩意就是用来存放我们这一对Buffer和Attribute Pointer的地方。因为VAO名字里面有Array，可推断VAO可以存储很多对Buffer和Attribute Pointer。</p><p>这个时候配上LearnOpenGL的图，感觉突然好懂了一些：</p><p><img loading=lazy src=/images/vertex_array_objects_ebo.png alt></p><h2 id=vao的结构示意图>VAO的结构示意图<a hidden class=anchor aria-hidden=true href=#vao的结构示意图>#</a></h2><p>等下，还有一个问题：再上图中，为什么VAO只保存了Attribute Pointer指针和EBO，没有保存Buffer的指针？因为Buffer的指针被放在了Attribute Pointer里面，我用C来描述一下就是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> VAO
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> AP[<span style=color:#ae81ff>16</span>] attributePointers;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> EBO<span style=color:#f92672>*</span> elementBufferObject;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> AP
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> Buffer<span style=color:#f92672>*</span> buffer;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// and code to guide OpenGL read buffer data
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=不吓人的-glbindxxx>不吓人的 glBindXXX<a hidden class=anchor aria-hidden=true href=#不吓人的-glbindxxx>#</a></h2><p>之前我们讨论过OpenGL本质上是一个状态机，因此我们需要在每一次绘图之前配置好我们“画笔”的参数，让它画出我们希望的图形。但是每一次画同样的东西都要让我重新配置OpenGL的话，是不是性能损耗太大了？</p><p>上面提到的Vertex Array Object就是用来解决这个问题的。我们预先定义好的“画笔”参数，到时候要用什么画笔直接拿来就能画，岂不美哉？</p><p>我们在绘制前，都需要调用<code>glBindVertexArray()</code>来绑定VAO与OpenGL，然后我们的OpenGL就会按VAO的信息来绘制图形。但其实我觉得一个比较讨厌的点在于，<code>glBindXXX()</code>调用的很频繁，有时候可能会弄不清楚我这个<code>glBindXXX()</code>是在干什么。所以我在这里简单补充一下LearnOpenGL的内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// 首先，我们要先绑定VAO，才能保证后续的操作是在给我们预期的VAO操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glBindVertexArray(VAO);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 然后，我们绑定我们要操作的Buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 需要注意的是，我们可以同时绑定Element Buffer和Array Buffer。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 我们后续的操作对操作目标是很明确的，不用担心数据错位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glBindBuffer(GL_ARRAY_BUFFER, VBO);
</span></span><span style=display:flex><span>glBindBuffer(GL_ELEMENT_BUFFER, EBO);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 接下来，给Buffer塞数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glBufferData(GL_ARRAY_BUFFER, ...);
</span></span><span style=display:flex><span>glBufferData(GL_ELEMENT_BUFFER, ...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 数据塞好了，给Vertex Array Buffer定义Attribute Pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 我曾疑惑为什么不在这里设定Buffer类型，但实际上这个函数只会使用到当前绑定的VAO，而不会使用到EBO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glVertexAttribPointer(...); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 启用刚刚做好的Attribute Pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glEnableVertexAttribArray(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 解除当前的所有绑定，方便进行下一步操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>glBindVertexArray(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>glBindBuffer(GL_ARRAY_BUFFER, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>glBindBuffer(GL_ELEMENT_BUFFER, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>实际上，在怎样使用OpenGL上的难点主要是搞清楚VAO、VBO和EBO三者的关系。这三者搞清楚了，OpenGL API剩下的内容都不会太难（但我没说图形学简单啊），只是说会很多很杂了。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ca2didi.xyz/tags/opengl/>OpenGL</a></li></ul><nav class=paginav><a class=prev href=https://ca2didi.xyz/posts/techs/why-unitask-good/><span class=title>« 上一页</span><br><span>为什么我们需要UniTask？谈论异步与Unity。</span></a>
<a class=next href=https://ca2didi.xyz/posts/thoughts/my-fathers/><span class=title>下一页 »</span><br><span>我和我的三个父亲</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ca2didi.xyz/>Ca2D Pages</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="复制";function s(){e.innerText="已复制！",setTimeout(()=>{e.innerText="复制"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>